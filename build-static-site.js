import os from 'os'
import fs from 'fs'
import { exec, execSync } from 'child_process'
import { parse } from 'node-html-parser'

// Use half of the available CPU cores for nbconvert processes to avoid zmq.error.ZMQError: Address already in use errors
const NUMBER_OF_CONVERTERS = Math.floor(os.cpus().length / 2);

const execute = (command) => {
    return new Promise((resolve, reject) => {
        exec(command, (error, stdout, stderr) => {
            if (error) {
                reject(`Error executing command: ${command}\n${error.message}`);
            } else {
                resolve(stdout);
            }
        });
    });
}

// Ensure the dist directory exists and is empty
if (fs.existsSync('dist')) {
    fs.rmSync('dist', { recursive: true, force: true });
}
fs.mkdirSync('dist', { recursive: true });

// Find all Jupyter notebooks in the ./notebooks directory
const allIpynbFiles = execSync('find ./notebooks -name "*.ipynb"').toString().split('\n').filter(f => f.trim() !== '');
const notebooks = allIpynbFiles.filter(f => !f.includes('ipynb_checkpoints')).map(notebook => {
    return {
        path: notebook,
        name: notebook.substring(notebook.lastIndexOf('/') + 1).replace('.ipynb', ''),
        link: '/' + notebook.replace('./notebooks/', '').replace('.ipynb', '.html'),
        location: notebook.substring(0, notebook.lastIndexOf('/')).replace('./notebooks', '').substring(1)
    };
});

// Generate HTML files for each notebook - generation is done in parallel in batches
const notebooksCopy = JSON.parse(JSON.stringify(notebooks)); // Deep copy to avoid mutation issues
console.log("Converting notebooks to HTML...");
while(notebooksCopy.length > 0) {
    const convertProcesses = [];

    for (const notebook of notebooksCopy.splice(0, NUMBER_OF_CONVERTERS)) {
        const convertProcess = execute(`.venv/bin/jupyter-nbconvert --to html --output-dir=dist/${notebook.location} --execute ${notebook.path} --embed-images --sanitize-html`);
        convertProcesses.push(convertProcess);
    }

    await Promise.all(convertProcesses);
}
console.log("Notebooks have been converted to HTML.");

// Copy public assets to dist
fs.cpSync('public/assets', 'dist/assets', { recursive: true });

// Generate links for the sidebar
const navigation = [];

const addLinkToNavigation = (notebook) => {
    const parentNames = notebook.link.split('/').filter(i => i && !i.endsWith('.html'));

    let currentLevel = navigation;
    for (let i = 0; i < parentNames.length; i++) {
        const parentName = parentNames[i];

        let parent = currentLevel.find(item => item.name === parentName);
        if (!parent) {
            currentLevel.push({
                name: parentName,
                children: []
            });
        }

        currentLevel = currentLevel.find(item => item.name === parentName).children;

        if (i === parentNames.length - 1 && currentLevel) {
            const id = `${notebook.name}-${Math.random().toString(36).substring(2, 15)}`;
            currentLevel.push({
                id,
                name: notebook.name,
                link: notebook.link,
                children: []
            });
        }
    }
}

notebooks.forEach(notebook => addLinkToNavigation(notebook));

fs.writeFileSync('dist/assets/navigation.js', `// This file is auto-generated by the build script.
const navigation = ${JSON.stringify(navigation)};

export { navigation };
`);

// Update pages with the sidebar

const templateHtml = parse(fs.readFileSync('public/template.html', 'utf8'));
const templateContent = templateHtml.querySelector('body').innerHTML;

// Update HTML of notebooks to include the sidebar
for (const notebook of notebooks) {
    const notebookHtml = parse(fs.readFileSync(`dist/${notebook.link}`, 'utf8'));

    // Add all style from template to the notebook
    templateHtml.querySelectorAll('head link').forEach(link => {
        const notebookHead = notebookHtml.querySelector('head');
        notebookHead.appendChild(link.clone());
    });

    // Add the sidebar
    const notebookBodyHtml = notebookHtml.querySelector('body');
    const existingNotebookContent = notebookBodyHtml.querySelector('main').innerHTML;

    const newNotebookContent = parse(templateContent);
    newNotebookContent.querySelector('main').innerHTML = existingNotebookContent;

    notebookBodyHtml.innerHTML = newNotebookContent.innerHTML;

    fs.writeFileSync(`dist/${notebook.link}`, notebookHtml.toString());
}
